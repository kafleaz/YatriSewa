@model TicketDetailsViewModel
@{
    ViewData["Title"] = "Home Page";
    Layout = "~/Views/Shared/_NoFooterLayout.cshtml";
}
<!-- Ticket Details -->
    <div class="osahan-header-nav shadow-sm p-3 d-flex align-items-center bg-darkblue">
        <h5 class="font-weight-normal mb-0 text-white">
            <a asp-controller="Passenger" asp-action="HomePage" class="text-darkblue mr-3">
                <i class="icofont-rounded-left"></i>
            </a>
            Your Bookings
        </h5>
        <div class="ml-auto d-flex align-items-center">
            <a class="toggle osahan-toggle h4 m-0 text-white ml-auto" href="#">
                <i class="icofont-navigation-menu"></i>
            </a>
        </div>
    </div>
<div class="your-ticket p-3">
    <h5 class="mb-3 font-weight-bold text-dark">@Model.BusName - @Model.BusNumber</h5>
    <p class="text-success mb-3 font-weight-bold">COMPLETED</p>
    <div class="bg-white border border-warning rounded-1 shadow-sm p-3 mb-3">
        <div class="row mx-0 mb-3">
            <div class="col-6 p-0">
                <small class="text-muted mb-1 f-10 pr-1">GOING FROM</small>
                <p class="small mb-0 l-hght-14">@Model.StartLocation</p>
            </div>
            <div class="col-6 p-0">
                <small class="text-muted mb-1 f-10 pr-1">GOING TO</small>
                <p class="small mb-0 l-hght-14">@Model.EndLocation</p>
            </div>
        </div>
        <div class="row mx-0">
            <div class="col-6 p-0">
                <small class="text-muted mb-1 f-10 pr-1">DATE OF JOURNEY</small>
                <p class="small mb-0 l-hght-14">@Model.DepartureTime.ToString("dd MMM yyyy")</p>
            </div>
            <div class="col-6 p-0">
                <small class="text-muted mb-1 f-10 pr-1">YOU RATED</small>
                <p class="small mb-0 l-hght-14"><span class="icofont-star text-warning"></span> 3.5</p>
            </div>
        </div>
    </div>
    <div class="bg-white rounded-1 d-flex shadow-sm p-3 mb-3 w-100">
        <div class="d-flex mx-0">
            <div class="col-12 p-0">
                <small class="text-danger mb-1 f-10 pr-1">PICKUP FROM</small>
                <p class="small mb-0 l-hght-14">@Model.PickupPoint</p>
            </div>
            <div class="col-12 p-0">
                <small class="text-danger mb-1 f-10 pr-1">DROPPING AT</small>
                <p class="small mb-0 l-hght-14">@Model.DropPoint</p>
            </div>
        </div>
    </div>
    <div class="list_item d-flex col-12 m-0 p-3 bg-white shadow-sm rounded-1 shadow-sm mb-3">
        <div class="d-flex w-100">
            <div class="bus_details w-100">
                <p class="mb-2 l-hght-18 font-weight-bold">View Boarding Location on Map</p>
                <div id="map" style="width: 100%; height: 400px; border-radius: 10px;"></div> <!-- Map container -->

                <div id="bus-details" style="margin-top: 20px;">
                    <h5>Bus Locator</h5>
                    @if (ViewBag.NoDeviceConnected != null && (bool)ViewBag.NoDeviceConnected)
                    {
                        <p style="font-size: 16px; color: red;">No IoT device connected for this bus.</p>
                    }
                    else
                    {
                        <p id="bus-info" style="font-size: 16px;">Waiting for updates...</p>
                        <p id="eta-info" style="font-size: 16px; color: green;">Calculating ETA...</p>
                    }
                </div>
            </div>
        </div>
    </div>
    

    @* <div class="list_item d-flex col-12 m-0 p-3 bg-white shadow-sm rounded-1 shadow-sm mb-3">
        <div class="d-flex mb-auto">
            <span class="icofont-location-pin h4"></span>
        </div>
        <div class="d-flex w-100">
            <div class="bus_details w-100 pl-3">
                <p class="mb-2 l-hght-18 font-weight-bold">View Boarding Location on Map</p>
                <div class="d-flex align-items-center mt-2">
                    <small class="text-muted mb-0 pr-1">Akshya Nagar 1st Block 1st Cross, Rammurthy<br>Nagar, Bangalore <br>560016</small>
                </div>
            </div>
        </div>
    </div> *@
    <div class="list_item d-flex col-12 m-0 mb-3 p-3 bg-white shadow-sm rounded-1 shadow-sm">
        <div class="d-flex mb-auto">
            <img src="data:image/png;base64,@ViewBag.QrCodeBase64" alt="QR Code" style="width: 100px; height: 100px;" />


        </div>
        <div class="d-flex w-100">
            <div class="bus_details w-100 pl-3">
                <p class="mb-2 l-hght-18 font-weight-bold">More Info</p>
                <div class="l-hght-10 d-flex align-items-center my-2">
                    <small class="text-muted mb-0 pr-1">Passenger</small>
                    <p class="small mb-0 ml-auto l-hght-14">@Model.PassengerName</p>
                </div>
                <div class="l-hght-10 d-flex align-items-center my-2">
                    <small class="text-muted mb-0 pr-1">Ticket Number</small>
                    <p class="small mb-0 ml-auto l-hght-14">@Model.TicketNumber</p>
                </div>
                <div class="l-hght-10 d-flex align-items-center my-2">
                    <small class="text-muted mb-0 pr-1">PNR Number</small>
                    <p class="small mb-0 ml-auto l-hght-14">@Model.PNR</p>
                </div>
                <div class="l-hght-10 d-flex align-items-center mt-3">
                    <p class="mb-0 pr-1 font-weight-bold">Amount Paid</p>
                    <p class="mb-0 ml-auto l-hght-14 text-danger font-weight-bold">Rs. @Model.TotalAmount</p>
                </div>
            </div>
        </div>
    </div>
<div class="bg-white rounded-1 shadow-sm p-3 w-100">
    <div>
        <div>
            <p class="text-justify">
                Cancellation Policies,<br>
                1. Get a minimum 50% refund if you cancel at least 12 hours before the departure.<br>
                2. Individual tickets can be canceled from multiple ticket bookings.<br>
                3. Cancellation charges:<br>
                &nbsp;&nbsp;Before 48 hours: 10%<br>
                &nbsp;&nbsp;Before 24 hours: 25%<br>
                &nbsp;&nbsp;Before 12 hours: 50%<br>
                &nbsp;&nbsp;After 12 hours: 100%<br>
            </p>
        </div>
    <form id="refundForm">
        @if (ViewBag.BookingId != null)
        {
                    <input type="hidden" id="bookingId" value="@ViewBag.BookingId" />
                    <input type="hidden" id="ticketId" value="@ViewBag.TicketId" />
        }
        else
        {
                    <script>console.error("⚠️ Error: ViewBag.BookingId is NULL! Check the controller.");</script>
        }
                <button type="button" id="refundButton" class="btn btn-danger">Cancel Ticket</button>
            </form>
    </div>
</div>
</div>
<!-- Download Ticket -->
<div class="pb-3 pt-0 px-3">
    <div class="footer-menu row m-0 px-1 bg-white shadow rounded-2">
        <div class="col-6 p-0 text-center">
            <a href="@Url.Action("DownloadTicket", "Passenger", new { bookingId = ViewBag.BookingId })" class="btn home text-danger py-3">
                <span class="icofont-file-pdf h5"></span>
                <p class="mb-0 small">Download Ticket</p>   
            </a>
        </div>
        <div class="col-6 p-0 text-center">
            <a href="#" class="home text-muted ">
                <span class="icofont-share h5"></span>
                <p class="mb-0 text-muted small">Share Ticket</p>
            </a>
        </div>
    </div>
</div>

<style>
    #map {
        width: 100%;
        height: 500px;
    }
</style>
<style>
    .bus-marker {
        border-radius: 50%;
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
    }
</style>

 <script>
    document.addEventListener("DOMContentLoaded", function () {
        var refundButton = document.getElementById("refundButton");

        if (!refundButton) {
            console.error("⚠️ Error: Refund button not found in DOM.");
            return;
        }

        refundButton.addEventListener("click", function () {
            requestStripeRefund();
        });
    });

    function requestStripeRefund() {
        var bookingIdElement = document.getElementById("bookingId");
        var ticketIdElement = document.getElementById("ticketId");

        if (!bookingIdElement) {
            console.error("⚠️ Error: #bookingId element not found in DOM.");
            return;
        }

        if (!ticketIdElement) {
            console.error("⚠️ Error: #ticketId element not found in DOM.");
            return;
        }

        var bookingId = bookingIdElement.value;
        var ticketId = ticketIdElement.value;

        console.log("🔍 Refund Request Booking ID:", bookingId);
        console.log("🔍 Refund Request Ticket ID:", ticketId);

        fetch('/PaymentRefund/ProcessStripeRefund', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ bookingId: parseInt(bookingId), ticketId: parseInt(ticketId) })
        })
        .then(response => response.json())
        .then(data => {
            alert(data.message);
            if (data.success) {
                console.log("✅ Refund processed successfully.");
            } else {
                console.error("❌ Refund failed:", data.message);
            }
        })
        .catch(error => console.error("❌ Refund Request Error:", error));
    }
</script>



@* <script src="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.js"></script>
<link href="https://api.mapbox.com/mapbox-gl-js/v2.14.1/mapbox-gl.css" rel="stylesheet" /> *@
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.6.1/firebase-database-compat.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/5.0.15/signalr.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/signalr/1.1.4/signalr.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/signalr/1.1.4/signalr.min.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>


@* <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/5.0.9/signalr.min.js"></script>
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" /> *@
<script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/5.0.15/signalr.min.js"></script>

<div id="bus-info" style="margin-top: 10px; font-weight: bold;"></div>
<script>
    const startCoords = [@ViewBag.StartLatitude, @ViewBag.StartLongitude];
    const endCoords = [@ViewBag.EndLatitude, @ViewBag.EndLongitude];
    const stops = JSON.parse('@Html.Raw(Json.Serialize(ViewBag.Stops))');  // Stops as an array of place names
    const deviceIdentifier = '@Model.DeviceIdentifier';

    let routePolyline, busMarker, isMapCentered = false;

    // Initialize Leaflet map
    const map = L.map('map').setView(startCoords, 10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Add start and end markers
    L.marker(startCoords).addTo(map).bindPopup('Start Location').openPopup();
    L.marker(endCoords).addTo(map).bindPopup('End Location');

    // Plot stops on the map
    stops.forEach(function(stop) {
        fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(stop)}`)
            .then(response => response.json())
            .then(data => {
                if (data.length > 0) {
                    const lat = parseFloat(data[0].lat);
                    const lon = parseFloat(data[0].lon);
                    L.marker([lat, lon]).addTo(map).bindPopup(stop);
                }
            })
            .catch(error => console.error(`Error fetching coordinates for stop: ${stop}`, error));
    });

    // Draw the static route through all stops
    drawStaticRoute();

    // Connect to the SignalR hub for real-time bus location
    const connection = new signalR.HubConnectionBuilder().withUrl("/busLocationHub").build();
    connection.start().then(() => {
        console.log("✅ SignalR connection established.");
        connection.invoke("JoinGroup", deviceIdentifier).catch(err => console.error("❌ Error joining group:", err));
    }).catch(err => console.error("❌ Error starting SignalR connection:", err));

    // Handle real-time bus location updates
    connection.on("UpdateBusLocation", (updatedDeviceIdentifier, busName, latitude, longitude, speed) => {
        if (updatedDeviceIdentifier === deviceIdentifier) {
            const busCoords = [latitude, longitude];
            console.log(`🚍 Bus ${busName} updated: [${latitude}, ${longitude}] at ${speed} km/h`);

            updateBusMarker(busCoords, speed > 0 ? 'green' : 'red');
            updateBusInfo(busName, speed);
            drawRouteFromBusToEnd(busCoords);
        }
    });



        async function snapToNearestRoad(coord) {
        const apiKey = '5b3ce3597851110001cf6248adb968e4ef8343b4bcb40689abd21300';
        const url = `https://api.openrouteservice.org/v2/nearest?api_key=${apiKey}&coordinates=${coord[1]},${coord[0]}`;

        try {
            const response = await fetch(url);
            const data = await response.json();
            if (data.waypoints?.length > 0) {
                const snappedCoord = data.waypoints[0].location;
                return [snappedCoord[1], snappedCoord[0]]; // Return as [latitude, longitude]
            }
        } catch (error) {
            console.error(`❌ Error snapping coordinate (${coord}):`, error);
        }
        return coord; // Return the original coordinate if snapping fails
    }



    // Function to draw the static route through all stops
             async function drawStaticRoute() {
        const apiKey = '5b3ce3597851110001cf6248adb968e4ef8343b4bcb40689abd21300';
        const waypointCoords = await getStopCoordinates();

        if (waypointCoords.length === 0) {
            console.warn("⚠️ No valid stop coordinates found.");
            return;
        }

        // Prepare coordinates: [longitude, latitude] in a comma-separated list
        const allCoords = [startCoords, ...waypointCoords, endCoords];
        const coordString = allCoords.map(coord => `${coord[1]},${coord[0]}`).join('|');

        const url = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${apiKey}&coordinates=${coordString}&format=geojson`;

        console.log('Request URL:', url);  // Debugging the URL

        try {
            const response = await fetch(url);
            const data = await response.json();
            if (data.features?.length > 0) {
                const coordinates = data.features[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
                routePolyline = L.polyline(coordinates, { color: 'blue', weight: 5 }).addTo(map);
                map.fitBounds(routePolyline.getBounds());
            } else {
                console.warn("⚠️ No valid static route data found.");
            }
        } catch (error) {
            console.error("❌ Error fetching static route:", error);
        }
    }
    async function drawRouteFromBusToEnd(busCoords) {
        const apiKey = '5b3ce3597851110001cf6248adb968e4ef8343b4bcb40689abd21300';
        const coordString = `${busCoords[1]},${busCoords[0]},${endCoords[1]},${endCoords[0]}`;
        const url = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${apiKey}&coordinates=${coordString}&format=geojson`;

        console.log('Real-Time Route Request URL:', url);

        try {
            const response = await fetch(url);
            const data = await response.json();
            if (data.features?.length > 0) {
                const coordinates = data.features[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
                if (routePolyline) map.removeLayer(routePolyline);
                routePolyline = L.polyline(coordinates, { color: 'green', weight: 5 }).addTo(map);

                if (!isMapCentered) {
                    map.fitBounds(routePolyline.getBounds());
                    isMapCentered = true;
                }
            } else {
                console.warn("⚠️ No valid real-time route data found.");
            }
        } catch (error) {
            console.error("❌ Error fetching real-time route:", error);
        }
    }







    // async function drawStaticRoute() {
    //     const apiKey = '5b3ce3597851110001cf6248adb968e4ef8343b4bcb40689abd21300';
    //     const waypointCoords = await getStopCoordinates();

    //     if (waypointCoords.length === 0) {
    //         console.warn("⚠️ No valid stop coordinates found.");
    //         return;
    //     }

    //     // Prepare coordinates for the API request: include start, all stops, and end
    //     const coords = [startCoords, ...waypointCoords, endCoords];
    //     const coordString = coords.map(coord => coord.reverse().join(',')).join('|');
    //     const url = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${apiKey}&coordinates=${coordString.replace(/\|/g, '%7C')}&format=geojson`;

    //     try {
    //         const response = await fetch(url);
    //         const data = await response.json();
    //         if (data.features?.length > 0) {
    //             const coordinates = data.features[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
    //             routePolyline = L.polyline(coordinates, { color: 'blue', weight: 5 }).addTo(map);
    //             map.fitBounds(routePolyline.getBounds());
    //         } else {
    //             console.warn("⚠️ No valid static route data found.");
    //         }
    //     } catch (error) {
    //         console.error("❌ Error fetching static route:", error);
    //     }
    // }

    // Function to get coordinates for all stops
    async function getStopCoordinates() {
        const waypointCoords = [];
        for (let stop of stops) {
            try {
                const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(stop)}`);
                const data = await response.json();
                if (data.length > 0) {
                    waypointCoords.push([parseFloat(data[0].lat), parseFloat(data[0].lon)]);
                } else {
                    console.warn(`⚠️ No coordinates found for stop: ${stop}`);
                }
            } catch (error) {
                console.error(`❌ Error fetching coordinates for stop: ${stop}`, error);
            }
        }
        return waypointCoords;
    }

    // Function to draw the route from the bus to the end location
    async function drawRouteFromBusToEnd(busCoords) {
        const apiKey = '5b3ce3597851110001cf6248adb968e4ef8343b4bcb40689abd21300';
        const url = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${apiKey}&start=${busCoords[1]},${busCoords[0]}&end=${endCoords[1]},${endCoords[0]}`;

        try {
            const response = await fetch(url);
            const data = await response.json();
            if (data.features?.length > 0) {
                const coordinates = data.features[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
                if (routePolyline) map.removeLayer(routePolyline);
                routePolyline = L.polyline(coordinates, { color: 'green', weight: 5 }).addTo(map);

                if (!isMapCentered) {
                    map.fitBounds(routePolyline.getBounds());
                    isMapCentered = true;
                }
            } else {
                console.warn("⚠️ No valid real-time route data found.");
            }
        } catch (error) {
            console.error("❌ Error fetching real-time route:", error);
        }
    }

    // Function to update the bus marker
    function updateBusMarker(busCoords, color) {
        if (busMarker) {
            busMarker.setLatLng(busCoords);
        } else {
            busMarker = L.circleMarker(busCoords, {
                color: color,
                radius: 10,
                fillColor: color,
                fillOpacity: 0.8
            }).addTo(map);
        }
    }

    // Function to update bus information on the UI
    function updateBusInfo(busName, speed) {
        const busInfoElement = document.getElementById("bus-info");
        busInfoElement.innerHTML = `<p>Bus "${busName}" is moving at ${speed} km/h.</p>`;
    }
</script>
@* <script>
    const startCoords = [parseFloat('@ViewBag.StartLatitude'), parseFloat('@ViewBag.StartLongitude')];
    const endCoords = [parseFloat('@ViewBag.EndLatitude'), parseFloat('@ViewBag.EndLongitude')];
    const stops = JSON.parse('@Html.Raw(Json.Serialize(ViewBag.Stops))'); // Stops as place names
    const deviceIdentifier = '@Model.DeviceIdentifier';
    let routePolyline, busMarker, isMapCentered = false;

    // Initialize Leaflet map
    const map = L.map('map').setView(startCoords, 10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Add start and end markers
    L.marker(startCoords).addTo(map).bindPopup('Start Location').openPopup();
    L.marker(endCoords).addTo(map).bindPopup('End Location');

    // Plot stops on the map with geocoding
    stops.forEach(function(stop) {
        fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(stop)}`)
            .then(response => response.json())
            .then(data => {
                if (data.length > 0) {
                    const lat = parseFloat(data[0].lat);
                    const lon = parseFloat(data[0].lon);
                    L.marker([lat, lon]).addTo(map).bindPopup(stop);
                }
            })
            .catch(error => console.error(`Error fetching coordinates for stop: ${stop}`, error));
    });

    // Draw the static route
    drawStaticRoute();

    // Connect to the SignalR hub for real-time bus location
    const connection = new signalR.HubConnectionBuilder().withUrl("/busLocationHub").build();
    connection.start().then(() => {
        console.log("✅ SignalR connection established.");
        connection.invoke("JoinGroup", deviceIdentifier).catch(err => console.error("❌ Error joining group:", err));
    }).catch(err => console.error("❌ Error starting SignalR connection:", err));

    // Handle real-time bus location updates
    connection.on("UpdateBusLocation", (updatedDeviceIdentifier, busName, latitude, longitude, speed) => {
        if (updatedDeviceIdentifier === deviceIdentifier) {
            const busCoords = [latitude, longitude];
            console.log(`🚍 Bus ${busName} updated: [${latitude}, ${longitude}] at ${speed} km/h`);

            updateBusMarker(busCoords, speed > 0 ? 'green' : 'red');
            updateBusInfo(busName, speed);
            drawRouteFromBusToEnd(busCoords);
        }
    });

    // Function to draw the static route
    async function drawStaticRoute() {
        const apiKey = '5b3ce3597851110001cf6248adb968e4ef8343b4bcb40689abd21300';
        const url = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${apiKey}&start=${startCoords[1]},${startCoords[0]}&end=${endCoords[1]},${endCoords[0]}`;

        try {
            const response = await fetch(url);
            const data = await response.json();
            if (data.features?.length > 0) {
                const coordinates = data.features[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
                routePolyline = L.polyline(coordinates, { color: 'blue', weight: 5 }).addTo(map);
                map.fitBounds(routePolyline.getBounds());
            } else {
                console.warn("⚠️ No valid static route data found.");
            }
        } catch (error) {
            console.error("❌ Error fetching static route:", error);
        }
    }

    // Function to draw the route from the bus to the end location
    async function drawRouteFromBusToEnd(busCoords) {
        const apiKey = '5b3ce3597851110001cf6248adb968e4ef8343b4bcb40689abd21300';
        const url = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${apiKey}&start=${busCoords[1]},${busCoords[0]}&end=${endCoords[1]},${endCoords[0]}`;

        try {
            const response = await fetch(url);
            const data = await response.json();
            if (data.features?.length > 0) {
                const coordinates = data.features[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
                if (routePolyline) map.removeLayer(routePolyline);
                routePolyline = L.polyline(coordinates, { color: 'green', weight: 5 }).addTo(map);

                if (!isMapCentered) {
                    map.fitBounds(routePolyline.getBounds());
                    isMapCentered = true;
                }
            } else {
                console.warn("⚠️ No valid real-time route data found.");
            }
        } catch (error) {
            console.error("❌ Error fetching real-time route:", error);
        }
    }

    // Function to update the bus marker
    function updateBusMarker(busCoords, color) {
        if (busMarker) {
            busMarker.setLatLng(busCoords);
        } else {
            busMarker = L.circleMarker(busCoords, {
                color: color,
                radius: 10,
                fillColor: color,
                fillOpacity: 0.8
            }).addTo(map);
        }
    }

    // Function to update bus information on the UI
    function updateBusInfo(busName, speed) {
        const busInfoElement = document.getElementById("bus-info");
        busInfoElement.innerHTML = `<p>Bus "${busName}" is moving at ${speed} km/h.</p>`;
    }
</script> *@


@* <script>
    const startCoords = [parseFloat('@ViewBag.StartLatitude'), parseFloat('@ViewBag.StartLongitude')];
    const endCoords = [parseFloat('@ViewBag.EndLatitude'), parseFloat('@ViewBag.EndLongitude')];
    const deviceIdentifier = '@Model.DeviceIdentifier';
    let routePolyline;
    let isMapCentered = false;
    let busMarker;

    // Initialize Leaflet map
    const map = L.map('map').setView(startCoords, 10);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Add static start and end markers
    L.marker(startCoords).addTo(map).bindPopup('Start Location').openPopup();
    L.marker(endCoords).addTo(map).bindPopup('End Location');

    // Draw the static route
    drawStaticRoute();

    // Connect to the SignalR hub
    const connection = new signalR.HubConnectionBuilder()
        .withUrl("/busLocationHub")
        .build();

    connection.start()
        .then(() => {
            console.log("✅ SignalR connection established.");
            connection.invoke("JoinGroup", deviceIdentifier)
                .then(() => console.log(`📡 Joined group for device: ${deviceIdentifier}`))
                .catch(err => console.error("❌ Error joining group:", err));
        })
        .catch(err => console.error("❌ Error starting SignalR connection:", err));

    // Handle real-time bus location updates
    connection.on("UpdateBusLocation", (updatedDeviceIdentifier, busName, latitude, longitude, speed) => {
        if (updatedDeviceIdentifier === deviceIdentifier) {
            const busCoords = [latitude, longitude];
            console.log(`🚍 Bus ${busName} updated: [${latitude}, ${longitude}] at ${speed} km/h`);

            updateBusMarker(busCoords, speed > 0 ? 'green' : 'red');
            updateBusInfo(busName, speed);
            drawRouteFromBusToEnd(busCoords);
        }
    });

    // Function to draw the static route
    async function drawStaticRoute() {
        const apiKey = '5b3ce3597851110001cf6248adb968e4ef8343b4bcb40689abd21300';
        const url = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${apiKey}&start=${startCoords[1]},${startCoords[0]}&end=${endCoords[1]},${endCoords[0]}`;

        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error("Failed to fetch route data.");
            const data = await response.json();

            if (data && data.features && data.features.length > 0) {
                const coordinates = data.features[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
                routePolyline = L.polyline(coordinates, { color: 'blue', weight: 5 }).addTo(map);
                map.fitBounds(routePolyline.getBounds());
            } else {
                console.warn("⚠️ No valid static route data found.");
            }
        } catch (error) {
            console.error("❌ Error fetching static route:", error);
        }
    }

    // Function to draw the route from the bus to the end location
    async function drawRouteFromBusToEnd(busCoords) {
        const apiKey = '5b3ce3597851110001cf6248adb968e4ef8343b4bcb40689abd21300';
        const url = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${apiKey}&start=${busCoords[1]},${busCoords[0]}&end=${endCoords[1]},${endCoords[0]}`;

        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error("Failed to fetch real-time route data.");
            const data = await response.json();

            if (data && data.features && data.features.length > 0) {
                const coordinates = data.features[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
                if (routePolyline) map.removeLayer(routePolyline);
                routePolyline = L.polyline(coordinates, { color: 'green', weight: 5 }).addTo(map);

                if (!isMapCentered) {
                    map.fitBounds(routePolyline.getBounds());
                    isMapCentered = true;
                }
            } else {
                console.warn("⚠️ No valid real-time route data found.");
            }
        } catch (error) {
            console.error("❌ Error fetching real-time route:", error);
        }
    }

    // Function to update the bus marker as a red or green circle
    function updateBusMarker(busCoords, color) {
        if (busMarker) {
            busMarker.setLatLng(busCoords);
        } else {
            busMarker = L.circleMarker(busCoords, {
                color: color,
                radius: 10,
                fillColor: color,
                fillOpacity: 0.8
            }).addTo(map);
        }
    }

    // Function to update bus information on the UI
    function updateBusInfo(busName, speed) {
        const busInfoElement = document.getElementById("bus-info");
        busInfoElement.innerHTML = `<p>Bus "${busName}" is moving at ${speed} km/h.</p>`;
    }
</script> *@








@* <script>
    const startCoords = [@ViewBag.StartLatitude, @ViewBag.StartLongitude];
    const endCoords = [@ViewBag.EndLatitude, @ViewBag.EndLongitude];
    const deviceIdentifier = '@Model.DeviceIdentifier';

    let markers = {};
    let routeLine, passengerMarker;
    const routeCoordinates = [startCoords, endCoords]; // Start and End coordinates
    let isMapCentered = false;

    const map = L.map('map').setView(startCoords, 7);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Place Start and End markers
    L.marker(startCoords).addTo(map).bindPopup('Start Location').openPopup();
    L.marker(endCoords).addTo(map).bindPopup('End Location').openPopup();

    // Connect to the SignalR hub
    const connection = new signalR.HubConnectionBuilder()
        .withUrl("/busLocationHub")
        .build();

    connection.start()
        .then(() => {
            console.log("SignalR connection established");
            connection.invoke("JoinGroup", deviceIdentifier)
                .then(() => console.log(`Joined group for device: ${deviceIdentifier}`))
                .catch(err => console.error("Error joining group:", err));
        })
        .catch(err => console.error("Error starting SignalR connection:", err));

    // Handle real-time bus location updates
    connection.on("UpdateBusLocation", (updatedDeviceIdentifier, busName, latitude, longitude, speed) => {
        if (updatedDeviceIdentifier === deviceIdentifier) {
            console.log(`Bus ${updatedDeviceIdentifier} updated: [${latitude}, ${longitude}] at ${speed} km/h`);

            const busCoords = [latitude, longitude];
            if (!markers[updatedDeviceIdentifier]) {
                const busIcon = L.icon({
                    iconUrl: '/img/gps.png',
                    iconSize: [40, 40],
                    iconAnchor: [20, 40]
                });
                markers[updatedDeviceIdentifier] = L.marker(busCoords, { icon: busIcon }).addTo(map);
            } else {
                markers[updatedDeviceIdentifier].setLatLng(busCoords);
            }

            // Update or draw the polyline for the route
            const fullRoute = [startCoords, busCoords, endCoords];
            if (routeLine) {
                routeLine.setLatLngs(fullRoute);
            } else {
                routeLine = L.polyline(fullRoute, { color: 'blue', weight: 5 }).addTo(map);
            }

            if (!isMapCentered) {
                map.fitBounds(routeLine.getBounds());
                isMapCentered = true;
            }

            // Update the bus info with speed and distance
            document.getElementById("bus-info").textContent = `Bus ${busName} is moving at ${speed} km/h.`;
        }
    });

    connection.onclose(async () => {
        console.log("Connection lost. Reconnecting...");
        try {
            await connection.start();
            connection.invoke("JoinGroup", deviceIdentifier);
            console.log(`Reconnected and joined group for device: ${deviceIdentifier}`);
        } catch (err) {
            console.error("Reconnection failed:", err);
        }
    });
</script>


<script>
    const busMarkerIcon = L.icon({ iconUrl: '/img/gps.png', iconSize: [40, 40], iconAnchor: [20, 40] });
    let busMarker, routePolyline;
    const map = L.map('map').setView([27.7172, 85.3240], 7);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Add start and end markers
    // const startCoords = [@ViewBag.StartLatitude, @ViewBag.StartLongitude];
    // const endCoords = [@ViewBag.EndLatitude, @ViewBag.EndLongitude];
    const startCoords = [parseFloat('@ViewBag.StartLatitude'), parseFloat('@ViewBag.StartLongitude')];
    const endCoords = [parseFloat('@ViewBag.EndLatitude'), parseFloat('@ViewBag.EndLongitude')];
    L.marker(startCoords).addTo(map).bindPopup('Start Location');
    L.marker(endCoords).addTo(map).bindPopup('End Location');

    const routeData = JSON.parse('@Html.Raw(Newtonsoft.Json.JsonConvert.SerializeObject(ViewBag.RouteData ?? "{}"))');

    // Load pre-fetched route from ViewBag.RouteData
    console.log("Route data:", routeData);

    if (routeData !== "null") {
        try {
            const data = JSON.parse(routeData);
            if (data.features && data.features.length > 0) {
                const coordinates = data.features[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
                routePolyline = L.polyline(coordinates, { color: 'blue', weight: 5 }).addTo(map);
                map.fitBounds(routePolyline.getBounds());
            } else {
                console.warn("No valid route data found.");
            }
        } catch (error) {
            console.error("Error parsing route data:", error);
        }
    } else {
        console.error("No route data available.");
    }

    let lastBusCoords = null;

    // Function to calculate distance between two coordinates (Haversine formula)
    function getDistance(lat1, lng1, lat2, lng2) {
        const R = 6371; // Radius of the Earth in km
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLng = (lng2 - lng1) * Math.PI / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                  Math.sin(dLng / 2) * Math.sin(dLng / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c; // Distance in km
    }

    // Handle real-time bus updates
    connection.on("UpdateBusLocation", (updatedDeviceIdentifier, busName, latitude, longitude, speed) => {
        const busCoords = [latitude, longitude];

        if (!busMarker) {
            busMarker = L.marker(busCoords, { icon: busMarkerIcon }).addTo(map);
        } else {
            busMarker.setLatLng(busCoords);
        }

        // Update the route if the bus moves significantly (more than 500 meters)
        if (lastBusCoords) {
            const distanceMoved = getDistance(lastBusCoords[0], lastBusCoords[1], latitude, longitude);
            if (distanceMoved > 0.5) {
                console.log(`Bus moved ${distanceMoved.toFixed(2)} km. Updating the route...`);
                getRoadRoute(busCoords);
            }
        }

        lastBusCoords = busCoords;

        document.getElementById("bus-info").innerHTML = `
            <p>Bus "${busName}" is moving at ${speed} km/h.</p>
        `;
    });

    async function getRoadRoute(busCoords) {
        const apiKey = '5b3ce3597851110001cf6248adb968e4ef8343b4bcb40689abd21300';
        const url = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${apiKey}&start=${busCoords[1]},${busCoords[0]}&end=${endCoords[1]},${endCoords[0]}`;

        try {
            const response = await fetch(url);
            if (!response.ok) throw new Error("Failed to fetch route data.");

            const data = await response.json();

            if (routePolyline) map.removeLayer(routePolyline);

            const coordinates = data.features[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
            routePolyline = L.polyline(coordinates, { color: 'blue', weight: 5 }).addTo(map);
            map.fitBounds(routePolyline.getBounds());

            const distance = data.features[0].properties.segments[0].distance / 1000;
            const duration = data.features[0].properties.segments[0].duration / 60;

            document.getElementById("bus-info").innerHTML += `
                <p>Distance to destination: ${distance.toFixed(2)} km</p>
                <p>ETA: ${Math.round(duration)} min</p>
            `;
        } catch (error) {
            console.error("Error fetching route:", error);
        }
    }
</script> *@




@* <script>
    const busMarkerIcon = L.icon({ iconUrl: '/img/gps.png', iconSize: [40, 40], iconAnchor: [20, 40] });
    let busMarker, routePolyline;
    const map = L.map('map').setView([27.7172, 85.3240], 7);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // Add start and end markers
    const startCoords = [@ViewBag.StartLatitude, @ViewBag.StartLongitude];
    const endCoords = [@ViewBag.EndLatitude, @ViewBag.EndLongitude];
    L.marker(startCoords).addTo(map).bindPopup('Start Location');
    L.marker(endCoords).addTo(map).bindPopup('End Location');

    // Function to fetch and display the road route and calculate distance & ETA
    async function getRoadRoute(busCoords) {
        const apiKey = '5b3ce359785111001cf6248adb968e4ef8343b4bcb40689abd21300';  // Your API key
        const url = `https://api.openrouteservice.org/v2/directions/driving-car?api_key=${apiKey}&start=${busCoords[1]},${busCoords[0]}&end=${endCoords[1]},${endCoords[0]}`;




        const response = await fetch(url);
        const data = await response.json();

        if (routePolyline) map.removeLayer(routePolyline);

        const coordinates = data.features[0].geometry.coordinates.map(coord => [coord[1], coord[0]]);
        routePolyline = L.polyline(coordinates, { color: 'blue', weight: 5 }).addTo(map);

        const distance = data.features[0].properties.segments[0].distance / 1000;  // Distance in kilometers
        const duration = data.features[0].properties.segments[0].duration / 60;  // Duration in minutes

        document.getElementById("bus-info").innerHTML = `
            <p>Bus is moving at ${speed} km/h.</p>
            <p>Distance to destination: ${distance.toFixed(2)} km</p>
            <p>ETA: ${Math.round(duration)} min</p>
        `;

        map.fitBounds(routePolyline.getBounds());
    }

    // Handle real-time bus updates
    connection.on("UpdateBusLocation", (updatedDeviceIdentifier, busName, latitude, longitude, speed) => {
        const busCoords = [latitude, longitude];
        if (!busMarker) {
            busMarker = L.marker(busCoords, { icon: busMarkerIcon }).addTo(map);
        } else {
            busMarker.setLatLng(busCoords);
        }

        getRoadRoute(busCoords);  // Fetch the road-based route
    });
</script>
 *@
